import { createContext, type ReactNode, useContext, useReducer } from "react";

export type Timer = {
  name: string;
  duration: number;
  isCompleted: boolean;
};

type TimersState = {
  isRunning: boolean;
  timers: Timer[];
  resetTimersNumber: number;
  intervalsCompleted: number;
  allTimersCompleted: boolean;
};

// preloaded timers
const initialTimersArray: Timer[] = [
  { name: "Starting Blocks,  5sec Timer", duration: 5, isCompleted: false },
  { name: "Quick Sprint, 15sec Timer", duration: 15, isCompleted: false },
  { name: "30sec Sprints", duration: 30, isCompleted: false },
];

const initialState: TimersState = {
  isRunning: false,
  timers: initialTimersArray,
  resetTimersNumber: 0, // # of times timers have been reset. incremented +=1 when timers are reset
  intervalsCompleted: 0, // # of intervals completed. (see TimerPopup.tsx)
  allTimersCompleted: false,
};

type TimersContextValue = TimersState & {
  // methods to update timers state
  addTimer: (timerData: Timer) => void; // adds individual timer
  completedTimer: (timerData: Timer) => void; // set isCompleted to true for individual timer
  startTimers: () => void; // starts all timers
  stopTimers: () => void; // stops all timers
  resetTimers: () => void; // resets all timers
  addInterval: () => void;
  markAllTimersCompleted: () => void;
  deleteTimer: (timerData: Timer) => void;
};

// ContextAPI context object
const TimersContext = createContext<TimersContextValue | null>(null);

// custom useContext()
export function useTimersContext() {
  const timersContext = useContext(TimersContext);
  // error checking resolves type errors
  if (timersContext === null) {
    throw new Error("Error! TimersContext is null. Requires error resolution.");
  }
  return timersContext;
}

// types for all actions
type TimersContextProvidersProps = {
  children: ReactNode;
};

type AddTimerAction = {
  type: "ADD_TIMER";
  payload: Timer;
};

type CompletedTimerAction = {
  type: "COMPLETED_TIMER";
  payload: Timer; // used to set isCompleted state for individual timer to true
};

type StartTimersAction = {
  type: "START_TIMERS";
};

type StopTimersAction = {
  type: "STOP_TIMERS";
};

type ResetTimersAction = {
  type: "RESET_TIMERS";
};

type AddIntervalAction = {
  type: "ADD_INTERVAL";
};

type DeleteTimerAction = {
  type: "DELETE_TIMER";
  payload: Timer; // name used to select and delete timer. (future implementation should use new autogenerated, unique to timer id value instead.)
};

type MarkTimersCompleteAction = {
  type: "MARK_ALL_TIMERS_COMPLETE";
};

type Action =
  | AddTimerAction
  | StartTimersAction
  | StopTimersAction
  | ResetTimersAction
  | AddIntervalAction
  | MarkTimersCompleteAction
  | DeleteTimerAction
  | CompletedTimerAction;

// Reducer fn updateing state. fn called by TimerContextProviders when theres a dispatch.
// calling a dispatch passes the dispatch values and current state to this fn. returns new TimersContext (context/state object)
function timersReducer(state: TimersState, action: Action): TimersState {
  // let currentResetTimers = state.resetTimersNumber;
  // let currentIntervalsCompleted = state.intervalsCompleted;
  if (action.type === "START_TIMERS") {
    return {
      ...state,
      isRunning: true,
    };
  }
  if (action.type === "STOP_TIMERS") {
    return {
      ...state,
      isRunning: false,
    };
  }
  if (action.type === "MARK_ALL_TIMERS_COMPLETE") {
    return {
      ...state,
      allTimersCompleted: true,
    };
  }
  if (action.type === "ADD_INTERVAL") {
    let currentIntervalsCompleted = state.intervalsCompleted;
    return {
      ...state,
      intervalsCompleted: (currentIntervalsCompleted += 1),
    };
  }
  if (action.type === "RESET_TIMERS") {
    let currentResetTimers = state.resetTimersNumber;
    return {
      ...state,
      resetTimersNumber: (currentResetTimers += 1),
      timers: state.timers.map((timer) =>
        timer.isCompleted === true ? { ...timer, isCompleted: false } : timer
      ),
      allTimersCompleted: false,
    };
  }
  if (action.type === "ADD_TIMER") {
    return {
      ...state,
      timers: [
        ...state.timers,
        {
          name: action.payload!.name,
          duration: action.payload!.duration,
          isCompleted: action.payload!.isCompleted,
        },
      ],
    };
  }
  if (action.type === "COMPLETED_TIMER") {
    return {
      ...state,
      timers: state.timers.map((timer) =>
        timer.name === action.payload!.name
          ? { ...timer, isCompleted: true }
          : timer
      ),
    };
  }

  if (action.type === "DELETE_TIMER") {
    return {
      ...state,
      timers: state.timers.filter(
        (timer) => timer.name !== action.payload!.name
      ),
    };
  }

  return state;
}

export function TimersContextProviders({
  children,
}: TimersContextProvidersProps) {
  // reducer fn called when theres a dispatch
  const [timersState, dispatch] = useReducer(timersReducer, initialState);

  // Current context object.
  const sharedContext: TimersContextValue = {
    // current states
    isRunning: timersState.isRunning,
    timers: timersState.timers,
    resetTimersNumber: timersState.resetTimersNumber,
    allTimersCompleted: timersState.allTimersCompleted,
    intervalsCompleted: timersState.intervalsCompleted,
    // methods that specify a dispatch
    // dispatch values (type, payload) and current state are passed to Reducer. Reducer updates state accordingly
    startTimers() {
      dispatch({ type: "START_TIMERS" });
    },
    stopTimers() {
      dispatch({ type: "STOP_TIMERS" });
    },
    resetTimers() {
      dispatch({ type: "RESET_TIMERS" });
    },
    addInterval() {
      dispatch({ type: "ADD_INTERVAL" });
    },
    markAllTimersCompleted() {
      dispatch({ type: "MARK_ALL_TIMERS_COMPLETE" });
    },
    // below methods dispatch with timerData payloads. payloads used by Reducer fn to update timers[] or individual timer in timers[] 
    addTimer(timerData) {
      dispatch({ type: "ADD_TIMER", payload: timerData });
    },
    deleteTimer(timerData) {
      dispatch({ type: "DELETE_TIMER", payload: timerData });
    },
    completedTimer(timerData) {
      dispatch({ type: "COMPLETED_TIMER", payload: timerData });
    },
  };

  return (
    <TimersContext.Provider value={sharedContext}>
      {children}
    </TimersContext.Provider>
  );
}
